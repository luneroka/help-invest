# HELP-INVEST

#### Site link: https://www.helpinvest.net

#### Video Demo: https://youtu.be/tMvmXQEJahI

#### Description:

The tool provides a clear overview of a user's portfolio. Whether they are beginner or experienced investor, it helps them visualize how their investments are distributed across different categories â€”without needing to check multiple accounts or apps. By regularly inputting their most recent investment operations, they can quickly assess if their portfolio aligns with their risk profile and make informed adjustments. The simple recommendation algorithm identifies gaps to guide user in making these decisions.

<ins>How it works:</ins>

1. User Signs up or Logs in.
2. User can define their risk profile (or use default : 'moderate').
3. User enters their investments by category and sub-category (e.g., Stocks > AMZN > $12,000).
4. View portfolio on the dashboard as a table, with personalized recommendations.
5. User to regularly update their portfolio to maintain balance.

<ins>How are the categories defined?</ins>

The app follows a very basic version of Maslow-inspired pyramid for financial investments:

- **Savings:** The base layer, focusing on securing liquidity for unexpected events.
- **Real Estate:** Once savings are secured, invest in property to build wealth.
- **Stock Market:** With security in place, invest in higher-risk, higher-reward assets like stocks or cryptocurrencies.

#### Tools

Here is a short list of the main tools and softwares that were used to build and manage the web-app :

- Local machine: Macbook Pro - M3 Pro
- VSCode desktop for writing code
- Flask live-server for live preview
- DB Browser for SQLite to vizualize database
- Git and GitHub for version control

#### Workflow

Here is the workflow of building the app:

1. Design of the web App

   I started designing the appearance of the app and made projections on basic functionalities (CRUD). Sketching the design on paper helped me decide what backend technologies were needed and which programming language to use.

   <ins>1.1 Backend (Python environment)</ins>
   **Backend Framework:** Flask was selected for running the app based on it's quick setup and seamless integration of SQLite database. A **config.py** file was created to hold Flask app and db initialization. **main.py** was set up to hold the backend routes and **helpers.py** for helper functions such as @login_required or usd conversion function.
   **Database:** database was designed on paper before any code was written. the following tables were added (Users, Categories, Portfolios, Transactions) and relationship were set into a **model.py** file. SQLAlchemy was used to manage local database during development phase and handle migration to PostgreSQL during deployment phase (via Alembic).

   <ins>1.2. Frontend (Jinja & Javascript)</ins>
   **Jinja** was selected as the preferred rendering method for it's simplicity of use and easy integration into HTML templates. The use of React components would have been a good option too but required learning a new Frontend Framework in a short timeframe.
   **Javascript** came into play for event listeners to render dynamic dropdown menus and other input boxes.

2. Backend routes

   Here is an exhaustive list of the routes in order of completion:

   **2.1. User authentication**

   /login, /logout, /signup, /change-password: all the basic necessary routes for account management, using Flask's session to handle user sessions and CS50 @login_required decorator to protect routes.

   **2.2. Dashboard**

   /dashboard: this is the user's landing page after loging-in. It allows user to view their investments in a table with a recommendation table next to it so the user can identify gaps between current and recommended portfolio allocations.

   **2.3. Add Entry**

   /add-entry: allows user to add investment logs to their portfolio using dropdown menus pre-filled with categories and sub-categories (or accounts).

   **2.4. Index**

   /index: home page displaying definition of the app (as in the Introduction section above) and a visual representation of the Maslow inspired pyramid of needs applied to finance (generated by Canvas AI). If logged in, user can access all the endpoints necessary to manage the account and portfolio. If not, user can signup of login from header links.

   **2.5. View History**

   /history: allows user to see past transactions made on their account by pulling data from a Transactions table and render it to UI.

   **2.6. Delete entry**

   /delete-entry: this route is inserted into the history page and listening to a delete button rendered in front of each row in the history table. It allows user to delete any previous entry with immediate effect on the database and corresponding dashboard rendering.

   **2.7. Withdraw**

   /withdraw: allows user to withdraw money from any of the accounts with their own amount, with direct impact on the database and corresponding dashboard rendering. Any withdrawal operation is set to pop up into the Transactions table (and therefore history table) with a negative amount value.

   **2.8. Risk Profile**

   /risk-profile: here the user can select their preferred risk profile out of three options: conservative, moderate or aggressive. Each profile holds a different portfolio repartition stores as a dictionary and used to dynamically render the recommendation table in the dashboard page.

   **2.9. Recommendation**

   Rendered with the dashboard GET request, this section provides a very simple comparison between current user's portfolio repartition and the recommended repartition based off user's risk profile.

3. Frontend rendering

   **3.1. HTML & Jinja2**

   The HTML templates have been added along with each of the routes to provide instant preview of the web app rendering.

   **3.2. Javascript**

   Javascript scripts were so few that a separate file was not deemed necessary. Every JavaScript was inserted at the bottom of the body tags for each file where it was needed.

   **3.3. Styling**

   Web-app styling was performed almost entirely with Bootstrap to serve quickness and efficiency purpose. Few particular styles were added into a single styles.css file common to all templates.

4. Noticeable functionalities

   **4.1. Error handling**

   Error messages were handles via FLASH messages, easy to set up and display with Bootstrap Alerts.
   Database errors were handled using try-except blocks with a rollback in case of exception to preserve database integrity at all steps.

   **4.2. SECRET_KEY and CSRF Token**

   A cryptographically secure SECRET KEY was set up using Python's 'secrets' module to handle session's flash messages and CSRF authorization, included in every form to secure data posting.

5. Debugging

   Choice was made not to dive into full-proof testing methods such as Vitest, due to the low complexity of the project and the time consuming engagement towards learning these tools.
   Instead, the routes were tested with basic usage and as much edge cases as possible at each step.

6. Deployment

   **6.1. Host**

   Heroku was chosen to host the website due to it's beginner friendly approach, it's free database hosting and automatic SSL certificate. The setup was made through their documentation and complementary internet tutorials.
   The first approach was to publish the files to Heroku using Heroku CLI. Later on, version control was managed with GitHub repository for better visibility on commits.

   **6.2. Database migration**

   After suscribing to Heroku's Postgres add-on, local database migration to the Heroku app was made using Alembic and flask_migrate. A few challenges were involved as the models were not imported correctly into the script so the upgrade() function had to be written manually.
